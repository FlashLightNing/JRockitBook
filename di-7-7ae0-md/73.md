# 7.3 扩展JRockit Mission Control Console {#73-扩展jrockit-mission-control-console}

本节将会对如何扩展JRockit Mission Control的Management Console进行介绍，读者在阅读之前，请先对Eclipse平台的相关技术有所了解，例如扩展点和FormPage。

要想实现自定义标签，可以使用控制台的扩展点。例如，从JRockit Mission Control更新站点创建JConsole插件标签页时，就有扩展点可用。有关更新站点的内容，请参见[第6章](../chap6/6.md#6)。

自定义JRockit MissionControl插件最简单的方法是使用PDE（Plugin Developement Eclipse）。首先，安装Eclipse for RCP/Plug-in Develpers（Eclipse 3.5/Ganymede或更高版本），然后，在Eclipse中安装JRockit Mission Control插件，最后安装PDE集成插件。

> PDE，即Plug-in Development Environment，是帮助创建/开发/调试/构建/部署Eclipse插件的一套开发工具。PDE集成插件专门提供的模板来简化创建JRockit Mission Control插件的工作。

在PDE中，有简单和高级两种方式可以方便的实现JRockit Mission Console Console中的自定义标签。简单方法会直接创建一个显示CPU负载的示例标签页，而高级方法会使用JRockit Mission Control Console中的内建组件来帮助创建标签页。

本节将会介绍，如果创建一个自定义标签页：

1. 选择菜单
   **文件 \| 新建 \| 项目…**

![](../images/7-33.jpg "Figure 7-33")

1. 在
   **新建项目**
   对话框中，选择
   **Plug-in Project**
   ，点击
   **下一步**

![](../chap6/6.md#6 "Figure 7-34")

1. 为项目取个名字。通常来说，一般会以插件的主包名来命名项目名，例如`com.example.mc.console.myplugin`

2. 确认正确选择了目标平台（针对JRockit Mission Console 3.1的Eclipse 3.4，或针对JRockit Mission Console 4.0的Eclipse 3.5）

!\[Figure 7-35\]\[3\]

1. 点击**下一步**，选择插件的详细属性，然后再次点击**下一步**

2. 如果PDE插件安装正确，这是就应该可以看到几种不同的模板，其中两种属于高级方法，一种属于简单方法。选择其中一种，点击**下一步**

!\[Figure 7-36\]\[4\]

1. 修改详细信息，点击
   **完成**

!\[Figure 7-37\]\[5\]

这样，就创建了一个插件工程，里面包含了自定义JRockit Mission Control Console标签页的必要代码。想要测试一下的话，只需点击**Run \| Run Configurations…**，在打开的**Run Configurations Dialog**对话框中，右键点击**Eclipse Application**选项，选择**New**创建一个新的运行配置项。默认情况下，会使用当前已经运行的Eclipse作为自定义插件的运行平台，而其中已经包含了JRockit Mission Control插件，所以一切看起来都很正常。接下来，选中这个新建的运行配置项，点击右下角的**Run**按钮。

这时，会启动一个新的Eclipse来部署这个自定义插件，打开**Mission Control**透视图，启动控制台后，就可以在**其他**标签页组中看到这个自定义的标签页了。

如果使用高级方式创建标签页的话，会创建一个具有与**概览**标签页相类似的、包含了基本代码的类文件，可以不同的方式展示3种不同的属性。

!\[Figure 7-38\]\[6\]

通过简单的编码即可完成标签页的配置工作，使用扩展点也只需要处理子类`org.eclipse.ui.forms.editor.FormPage`，无需依赖于JRockit或JRockit Mission Control的某个类。来自表单页面的编辑器输入内容会被适配为`IMBeanService`，用于`com.jrockit.mc.rjmx.core`包中的控制台进行通信。

```

```

这样，对JRockit Mission Control的访问就可以被指定到位于`com.jrockit.mc.rjmx*`插件中的MBean层。除此之外，RJMX还提供了对JRockit Mission Control中的订阅引擎和代理层的访问功能。

代理层可通过专有的API访问JRockit中的属性和操作，使用`getMBeanService().getProxyNames()`来访问属性，使用`getMBeanService().getProxyOperations()`来访问操作

例如，反应CPU负载的属性在JRockit的R26.4，R27.x和R28.x中都各不相同，为了能够无差别的访问CPU负载这个属性，可以通过代理层来实现，如下所示：

```

```

上面的代码会返回一个包含了MBean对象`ObjectName`和属性名的属性描述符（attribute descriptor），大部分RJMX所使用属性描述符都是对MBean对象的`ObjectName`和属性名的封装。

下面的代码展示如何在R28版本中创建一个指向CPU负载属性的属性描述符：

```

```

要想在多个JRockit版本之间，无差别的调用垃圾回收操作，可以通过以下方式完成：

```

```

正如在高级模板的代码所见，添加一个包含了多个属性的表格其实非常简单：

```

```

实际上，简单模板的代码并不像看起来那么容易，因为它直接使用了不同的服务，而不依赖于标准的Mission Control GUI组件，不过正因如此，GUI的实现也更简单一些。使用简单模板生成的标签页很好的展示了如何使用RJMX订阅服务。通过订阅机制，客户端订阅一个或多个属性值的变动情况，通过`SubscriptionService`类即可完成对CPU负载属性值的订阅：

```

```

`LabelUpdater`类是对`com.jrockit.mc.rjmx.subscription.IAttributeValueListener`接口的简单实现。每次获取新属性值的时候，都会调用`valueChanged`方法，并附带一个包含了属性值的事件对象。注意，这里并不能保证是哪个线程发起了事件，在目前的实现中，可能是订阅线程，也可能是JMX的某个子系统的线程。一般情况下，绝不会是GUI线程发起了事件，因此更新GUI的工作需要专门交给GUI线程完成，并调用`DisplayToolkit.safeAsyncExce`方法。示例代码如下所示：

```

```

为触发器动作创建扩展也是一样的道理，在第6步中，选择**Mission Control Trigger Action Wizard**即可。

